<edit_condition>
    <edit_modal modal_id="{ modal_id }" disableSave="{ !state.canSave }">
        <span slot="modal_title">Add Surface Condition Information</span>

        <form slot="modal_body">
            <section>
                <div class="form-group">
                    <label>{ window.gettext("Survey Date") }</label>
                    <small class="form-text text-muted">{props.getHelpText("survey_date")}</small>
                    <!-- It would be preferable to use the 'datetime-local' input type, however Firefox currently does not support it -->
                    <input class="{ state.errors.surveyDate ? 'danger' : null } { state.survey.surveyDate ? '' : 'inactive' } form-control"
                        type="date" name="surveyDate" placeholder="Date" value="{ state.survey.surveyDate }" oninput="{ checkSurveyDate }"
                        required pattern="\d{4}-\d{2}-\d{2}" max="{ max_date() }" >
                    <div if="{ state.errors.surveyDate }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.surveyDate }.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section>
                <h6>{ window.gettext("Chainage") }</h6>
                <div class="form-group">
                    <label>{ window.gettext("Chainage start") }</label>
                    <input class="{ state.errors.startChainage ? 'danger' : null } { state.survey.startChainage ? '' : 'inactive' } form-control"
                        type="number" name="startChainage" placeholder="0+000" value="{ state.survey.startChainage }" oninput="{ checkChainage }"
                        required>
                    <small class="form-text text-muted">{ props.getHelpText("start_chainage") }</small>
                    <div if="{ state.errors.startChainage }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.startChainage }.</li>
                        </ul>
                    </div>
                </div>
                <div class="form-group">
                    <label>{ window.gettext("Chainage end") }</label>
                    <input class="{ state.errors.endChainage ? 'danger' : null } { state.survey.endChainage ? '' : 'inactive' } form-control"
                        type="number" name="endChainage" placeholder="62+410" value="{ state.survey.endChainage }" oninput="{ checkChainage }"
                        required>
                    <small class="form-text text-muted">{ props.getHelpText("end_chainage") }</small>
                    <div if="{ state.errors.endChainage }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.endChainage }.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section>
                <h6>{ window.gettext("Condition") }</h6>
                <div class="form-group">
                    <label>{conditions.display}</label>
                    <small class="form-text text-muted">{props.getHelpText("surface_condition")}</small>
                    <div if="{ state.errors.surfaceCondition }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.surfaceCondition }.</li>
                        </ul>
                    </div>
                    <ul class="surface-condition">
                        <li each="{ condition in conditions.options }" data-condition="{ condition[0] }" onclick="{ checkSurfaceCondition }">
                            <span class="{ condition[0] == state.survey.surfaceCondition ? 'active' : ''  } radio image"></span>
                            { condition[1] }
                        </li>
                    </ul>
                </div>
            </section>
        </form>
    </edit_modal>

    <h5>{ window.gettext ("Condition") }</h5>
    <section>
        <div class="form-group">
            <div class="button-wrapper d-flex justify-content-end">
                <button class="btn btn-primary" onclick="{ addEdit }" disabled="{ props.editing }">{ window.gettext("Add") }</button>
            </div>
        </div>
        <data_table table_id="{this.table_id}" columns="{this.table_columns}" getHelpText="{props.getHelpText}" pendingRows="{this.pendingRows}"></data_table>
    </section>

    <script>
        import Data_Table from "./data_table.riot";
        import Edit_Modal from "./edit_modal.riot";

        import { getRoadSurveys } from "../surveyManager"
        import { getFieldName } from "../road";

        import $ from "jquery";

        function checkRequiredFields(fieldNames, data, errors) {
             return fieldNames.filter((fieldName) => { return !data[fieldName]; });
        }

        function withinMaxDigits(text, limit, decimals) {
            return (new RegExp(`^\\d{0,${(limit - decimals)}}(\\.\\d{1,${decimals}})?$`).test(text));
        }

        /** Deep copy the supplied data to a new object
         *  Prefers to use protobuf .cloneMessage
         */
        function cloneData(data) {
            if (data.cloneMessage) {
                return data.cloneMessage();
            }

            return JSON.parse(JSON.stringify(data));
        }

        export default {
            state: {
                chainageDecimals: 3,
                chainageDigits : 7,
                baseSurvey: {},
                survey: {},
                canSave: false,
                errors: {},
                pendingRows: [],
            },
            components: {
                Edit_Modal
            },

            // Condition Survey

            onMounted(props, state) {
                state.loading = true;
                state.road = cloneData(props.road);
                this.getRoadSurveys();
            },
            getRoadSurveys() {
                const roadCode = this.state.road.getId();
                getRoadSurveys(roadCode)
                    .then((surveyData) => {
                        if (surveyData) {
                            this.state.pendingRows = surveyData;
                            const pendingRows = this.state.pendingRows;
                            document.dispatchEvent(new CustomEvent(`${this.table_id}.dataAdded`, {detail: { pendingRows }}));
                            this.state.error = false;
                        } else {
                            this.state.error = true;
                        }
                    }).catch(err => {
                        this.state.error = true;
                    }).finally((r) => {
                        this.state.loading = false;
                        this.update();
                    });
            },
            addEdit(e) {
                // TODO:
                // baseSurvey must be set to 'empty' for add.
                // and the selected segment survey for edit.
                this.state.survey = cloneData(this.state.baseSurvey);
                this.state.errors = {};

                this.showEditModal();
            },
            conditions: window.road_schema.surface_condition,
            table_id: "surface-condition-table",
            table_columns: [
                {
                    title: window.gettext("Chainage start"), 
                    data: "chainageStart",
                    defaultContent: "",
                },
                {
                    title: window.gettext("Chainage end"), 
                    data: "chainageEnd",
                    defaultContent: "",
                },
                {
                    title: window.gettext("Surface condition"), 
                    data: "surfaceCondition",
                    defaultContent: "",
                },
                {
                    title: window.gettext("Survey date"),
                    data: "dateSurveyed",
                    defaultContent: "",
                },
                {
                    title: window.gettext("Added by"), 
                    data: "user",
                    defaultContent: "",
                },
                {
                    title: window.gettext("Source"), 
                    data: "source",
                    defaultContent: "",
                },
            ],

            // Survey Modal 

            requiredFieldNames: ["surveyDate", "startChainage", "endChainage", "surfaceCondition"],
            showEditModal() {
                document.addEventListener(`${this.modal_id}.result`, (data) => {
                    const modalResult = data.detail.result;

                    console.log(`Received '${this.modal_id}' result: ${modalResult}`);

                    // Ensure that the dialog gets hidden
                    $(`#${this.modal_id}`).modal("hide");

                    switch (modalResult) {
                        case "save":
                            if (this.hasChanges()) {
                                this.save();
                            }
                            break;
                        case "cancel":
                            this.discardChanges();
                            break;
                        default:
                            if (this.hasChanges()) {
                                this.showStopAlertModal();
                            }
                            break;
                    }
                }, { once: true });

                $(`#${this.modal_id}`).modal("show");                
            },
            showStopAlertModal() {
                document.addEventListener("edit.stop_alert.result", (data) => {
                    const stopAlertResult = data.detail.result;

                    console.log(`Received 'Stop Alert' result: ${stopAlertResult}`);

                    // Ensure that the dialog gets hidden
                    $("#stop-alert").modal("hide");
                    
                    if (stopAlertResult === "discard") {
                        this.discardChanges();
                    } else {
                        // continueEdit and close
                        this.showEditModal();
                    }
                }, { once: true });

                $("#stop-alert").modal("show");
            },
            discardChanges() {
                this.state.survey = cloneData(this.state.baseSurvey);
                this.state.errors = {};
                this.update();
            },
            save(e) {
                const missingFieldNames = checkRequiredFields(this.requiredFieldNames, this.state.survey);

                if (Object.keys(this.state.errors).length) {
                    // Cannot save if there are validation errors
                    this.canSave();

                    if (!this.state.canSave) {
                        missingFieldNames.forEach((fieldName) => {
                            if (!data[fieldName]) {
                                errors[fieldName] = window.gettext("This field is required");
                            }
                        });
                        this.showEditModal();
                    }
                } else {
                    if (this.hasChanges()) {
                        // Complete the survey
                        this.state.survey.user = $("#user_welcome").data( "userName" ) || "Unknown";
                        this.state.survey.source = this.modal_id;
                        
                        this.props.onSave();
                    }

                    // Reset baseSurvey now that we're done.
                    this.baseSurvey = {};

                    $(`#${this.modal_id}`).modal("hide");
                } 
            },
            saveSurvey(mode) {
                if (mode == 'create') {
                    this.props.onCreateSurvey();
                } else {
                    this.props.onUpdateSurvey();
                }
            },
            canSave() {
                const missingFieldNames = checkRequiredFields(this.requiredFieldNames, this.state.survey);

                if (missingFieldNames.length || Object.keys(this.state.errors).length) {
                    // Cannot save if there are validation errors
                    this.state.canSave = false;
                } else {
                    // Can save if something has changed
                    this.state.canSave = JSON.stringify(this.state.baseSurvey) !== JSON.stringify(this.state.survey);
                }

                this.update();
            },
            /** Compare the selected fields between baseSurvey and survey.
             * `source` and `user` are deliberately not compared
             */
            hasChanges() {
                const compareFieldNames = ["surveyDate", "startChainage", "endChainage", "surfaceCondition"];
                const surveyBase = compareFieldNames.map((fieldName) => { return this.state.baseSurvey[fieldName] || ""; }).join("|||");
                const surveyResult = compareFieldNames.map((fieldName) => { return this.state.survey[fieldName] || ""; }).join("|||");

                return (surveyBase !== surveyResult);
            },
            validate(fieldName, input, testResult, errorText) {
                if (!testResult) {
                    this.state.errors[fieldName] = errorText;                    
                } else {
                    delete this.state.errors[fieldName];
                    this.state.survey[fieldName] = input;
                }

                this.canSave();
            },
            checkSurveyDate(e) {
                const fieldName = e.currentTarget.name;
                const input = e.currentTarget.value;
                const testResult = input < this.max_date();
                const errorText = window.gettext("Survey date cannot be in the future");

                this.validate(fieldName, input, testResult, errorText );
            },
            checkChainage(e) {
                const fieldName = e.currentTarget.name;
                const input = e.currentTarget.value;
                const chainageDigits = this.state.chainageDigits;
                const chainageDecimals = this.state.chainageDecimals;
                const testResult = withinMaxDigits(input, chainageDigits, chainageDecimals);
                const errorText = window.interpolate(
                    window.gettext("Chainage cannot contain more than %s digits, of which %s are decimals"),
                    [chainageDigits, chainageDecimals]);

                this.validate(fieldName, input, testResult, errorText);
            },
            checkSurfaceCondition(e) {
                this.state.survey.surfaceCondition = e.currentTarget.dataset.condition;
                this.canSave();
            },
            modal_id: "surface-condition-modal",
            max_date: () => { return (new Date()).toISOString().substring(0, 10); }
        }
    </script>
</edit_condition>
