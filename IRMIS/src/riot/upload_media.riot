<upload_media>
    <form id="dropzone-{ props.mediaid }" class="dropzone">
        <div class="cloud-box">
            <span class="image upload-cloud"></span>
            <div class="upload-instructions">{ window.gettext("Click to upload") }</div>
            <div>{ window.gettext("Maximum file size 25MB") }</div>
            <div class="text-center">{ window.gettext("Accepted file formats: JPEG, GIF, PNG, MP4, MOV, MPG, AVI, WMV, 3GP, TS, ASF, MNG, M4V, FLV, or WEBM") }</div>
        </div>
    </form>
    <div if="{ state.media.url && state.media.url != '' && state.media.url != state.baseMedia.url }" class="media-management-area">
        <div>
            <img if="{ isImage(state.media) }" class="uploaded-media" src="{ state.media.url }" />
            <template if="{ isVideo(state.media) }">
                <video class="uploaded-media" controls>
                    <source src="{ state.media.url }"></source>
                    <a target="_blank">{ state.media.url }</a>
                </video>
            </template>
            <button class="btn btn-sm btn-secondary" onclick="{ deleteMedia }">{ window.gettext("Delete Photo/Video") }</button>
        </div>
        <input
            class="{ state.errors.description ? 'danger' : null } { !state.media.description ? 'inactive' : '' } form-control edit-caption"
            type="text" maxlength="500" placeholder="{ window.gettext('Enter a description of the photo/video') }"
            value="{ state.media.description }" onblur="{ updateDescription }">
        <small class="form-text text-muted">
            { window.gettext("Uploaded by") }: { state.media.getAddedBy() } { window.gettext("on") } { state.media.date_created || state.media.dateCreated }
        </small>
    </div>

    <script>
        import Dropzone from "dropzone";
        import dayjs from "dayjs";

        import { ConfigAPI } from "../assets/configAPI";
        import { putMediaData, deleteMediaData } from "../assets/mediaAPI";
        import { EstradaMedia } from "../assets/models/media";
        import { isImage, isVideo } from "../assets/editUtilities";

        export default {
            state: {
                errors: {},
            },
            onBeforeMount(props, state) {
                state.baseMedia = new EstradaMedia();
                state.media = props.media || new EstradaMedia();
            },
            onMounted(props, state) {
                Dropzone.autoDiscover = false;
                const myDropzone = new Dropzone(this.$('form.dropzone'), {
                    url: `${ConfigAPI.requestAssetUrl}/media_create`,
                    method: "post",
                    headers: {'X-CSRFToken': document.cookie.replace(/(?:(?:^|.*;\s*)csrftoken\s*\=\s*([^;]*).*$)|^.*$/, "$1")},
                    params: {fk_link: props.fklink},
                    clickable: `#dropzone-${ props.mediaid } > div.cloud-box`,
                    maxFiles: 1,
                    maxFilesize: 25.0, // MB
                    acceptedFiles: '.jpeg,.jpg,.gif,.png,.mp4,.mov,.mpg,.avi,.wmv,.3gp,.ts,.asf,.mng,.m4v,.flv,.webm',
                    dictDefaultMessage: '',
                    dictInvalidFileType: 'Not a valid image(JPEG, GIF, or PNG) or video(MP4 or MOV)',
                    accept: (file, done) => {
                        myDropzone.options.params["description"] = state.media.description;
                        done();
                    }
                });

                // hide the dropzone on mount if there's a media on hand to show
                if (state.media.url != state.baseMedia.url) {
                    document.getElementById("dropzone-" + props.mediaid).style.display = 'none';
                }

                this.mediaCreationListener = (data) => {
                    const media = data.detail.media;
                    this.state.media.setId(media.id);
                    this.state.media.setUrl(media.url);
                    this.state.media.setFkLink(media.fk_link);
                    this.state.media.setDescription(media.description);
                    this.state.media.setAddedBy(media.added_by);
                    this.state.media.date_created = media.date_created;

                    // add it to the NeedsLinkingQueue
                    document.dispatchEvent(new CustomEvent(`${props.mediaid}.mediaNeedsLinking`, {detail: {media: this.state.media}}));

                    this.update();
                };

                document.addEventListener(`${props.mediaid}.mediaCreated`, this.mediaCreationListener);

                this.mediaClearedListener = (data) => {
                    this.state.media = new EstradaMedia();
                    this.update();
                }
                document.addEventListener(`${props.mediaid}.mediaCleared`, this.mediaClearedListener);

                myDropzone.on("success", function(file, res) {
                    myDropzone.removeAllFiles();
                    // hide the dropzone
                    document.getElementById("dropzone-" + props.mediaid).style.display = 'none';
                    document.dispatchEvent(new CustomEvent(`${props.mediaid}.mediaCreated`, {detail: {media: res}}));
                });
                this.update();
            },
            isImage(media) {
                return isImage(media);
            },
            isVideo(media) {
                return isVideo(media);
            },
            updateMedia() {
                putMediaData(this.state.media)
                    .then((data) => {
                        document.dispatchEvent(new CustomEvent(`${this.props.mediaid}.mediaNeedsLinking`, {detail: {media: data}}));
                    }).catch((err) => {
                        this.props.showfeedback(true);
                    }).finally(() => {
                        this.update();
                    });
            },
            deleteMedia(e) {
                e.preventDefault();
                deleteMediaData(this.state.media)
                    .then((data) => {
                        // before resetting state.media, remove from the NeedsLinkingQueue, if present.
                        document.dispatchEvent(new CustomEvent(`${this.props.mediaid}.mediaNeedsRemoval`, {detail: {media: data}}));
                        if (!this.props.surveymedia) {
                            // only if NOT a survey Media, show feedback
                            this.props.showfeedback();
                        }
                        this.state.media = new EstradaMedia();
                        // show the dropzone
                        document.getElementById(`dropzone-${this.props.mediaid}`).style.display = 'inline-block';
                    }).catch((err) => {
                        this.props.showfeedback(true);
                    }).finally(() => {
                        this.update();
                    });
            },
            updateDescription(e) {
                const description = e.currentTarget.value.trim();
                if (this.state.media.description != description) {
                    this.state.media.setDescription(description);
                    // check that a media is uploaded/present first before firing an update
                    if (this.state.media.url != this.state.baseMedia.url) {
                        this.updateMedia();
                    }
                }
            },
        }
    </script>
</upload_media>
