<report>
    <div class="print-header">
        <div class="align-items-center d-flex">
            <span class="image rdtl"></span>
            <div class="d-flex flex-column">
                <span>{ window.gettext("Democratic Republic of Timor-Leste") }</span>
                <span>{ window.gettext("Ministry of Public Works") }</span>
                <span>{ window.gettext("Directorate General for Public Works") }</span>
                <span>{ window.gettext("National Directorate for Roads, Bridges and Flood Control") }</span>
                <small>Avenida da Restauração, Rai Kotu, Díli, Timor-Leste, Telf. +670 3311408</small>
            </div>
        </div>
    </div>

    <header>
        <div>
            <a class="caret-dark left image" onclick="{ backToReports }"></a>
        </div>
        <div class="d-flex flex-column">
            <div class="align-items-center d-flex">
                <span class="paper image"></span>
                <h6>{ reportContent().title }</h6>
            </div>
            <div>
                <p>{ reportContent().description }.</p>
            </div>
        </div>
    </header>

    <div class="content-wrapper report-criteria">
        <h6>{ window.gettext("Select report criteria") }</h6>
        <div class="d-flex justify-content-between">
            <div class="d-flex flex-wrap">
                <div if="{ reportContent().visibleFilters.municipality }" class="options">
                    <select id="municipality_area_select2" multiple="true">
                        <option each="{ area in window.road_schema.administrative_area.options }" value="{ area.id }">{ area.name }</option>
                    </select>
                </div>

                <div if="{ reportContent().visibleFilters.roadClass }" class="options">
                    <select id="road_class_select2" multiple="true">
                        <option each="{ road_class in window.road_schema.road_type.options }" value="{ road_class[0] }">{ road_class[1] }</option>
                    </select>
                </div>
                <!-- Optionally include the following to show the fixedFilter value (changing to the full option title) -->
                <!-- <div if="{ reportContent().fixedFilter.road_type }" class="options">
                    <span>{ reportContent().fixedFilter.road_type }</span>
                </div> -->

                <div if="{ reportContent().visibleFilters.surfaceType }" class="options">
                    <select id="surface_type_select2" multiple="true">
                        <option each="{ surface_type in window.road_schema.surface_type.options }"
                            value="{ surface_type.code }">{ surface_type.name }</option>
                    </select>
                </div>

                <div if="{ reportContent().visibleFilters.surfaceCondition }" class="options">
                    <select id="surface_condition_select2" multiple="true">
                        <option each="{ surface_condition in window.road_schema.surface_condition.options }"
                            value="{ surface_condition[0] }">{ surface_condition[1] }</option>
                    </select>
                </div>

                <div if="{ reportContent().visibleFilters.roadCode }">
                    <div class="options">
                        <select id="road_code_select2" multiple="true">
                            <option each="{ code in window.road_schema.road_code.options }"
                                value="{ code.road_code }">{ code.road_code }</option>
                        </select>
                    </div>
                    <div class="chainages d-flex flex-wrap">
                        <div class="align-items-center d-flex flex-column justify-content-between">
                            <label>{ window.gettext("Chainage start") } (m)</label>
                            <input class="{ state.reportStartChainage ? '' : 'inactive' } form-control form-control-sm"
                                type="number" oninput="{ selectStartChainage }" placeholder="0" min="0" step="1">
                        </div>
                        <div class="align-items-center d-flex flex-column justify-content-between">
                            <label>{ window.gettext("Chainage end") } (m)</label>
                            <input class="{ state.reportEndChainage ? '' : 'inactive' } form-control form-control-sm"
                                type="number" oninput="{ selectEndChainage }" placeholder="20000" min="0" step="1">
                        </div>
                    </div>
                </div>

                <input if="{ reportContent().visibleFilters.reportDate }"
                    class="{ state.reportDate ? '' : 'inactive' } form-control form-control-sm" type="date"
                    oninput="{ selectDate }" value="{ current_date() }" max="{ max_date() }" placeholder="Select Date"
                    pattern="\d{4}-\d{2}-\d{2}">
            </div>
            <div>
                <button type="button" class="btn btn-primary" onclick="{ createReport }" data-id="{ props.id }">{ window.gettext("Create Report") }</button>
            </div>
        </div>
    </div>

    <div hidden="{ state.noReport || state.noReportData }" class="content-wrapper report-content">
        <div class="align-items-center d-flex justify-content-between">
            <h1 class="print-title">{ window.gettext("Road Asset Management") }</h1>
            <h6>{ reportContent().title } { window.gettext("Report") }</h6>
            <button class="btn btn-secondary btn-sm" onclick="{ () => window.print() }">{ window.gettext("Print") }</button>
        </div>

        <div class="filtered-segment" hidden="{ !hasRoadCodeAndChainage() }">
            <h6 if="{ state.reportData.roadCodes && state.reportData.roadCodes.length === 1 }">{ window.gettext("Road") } { state.reportData.roadCodes[0] }</h6>
            <h6 if="{ state.reportData.reportChainage }">, { window.gettext("Chainage") } { toChainageFormat(state.reportData.reportChainage[0]) } { window.gettext("to") } { toChainageFormat(state.reportData.reportChainage[1]) }</h6>
        </div>

        <span class="report-date" if="{ state.reportData.dateCreated }">{ window.gettext("Created on") } { state.reportData.dateCreated() }</span>

        <div class="filters-applied" hidden="{ !hasFilters() || !state.reportData.formattedFilters || !state.reportData.formattedFilters.length }">
            <p>{ window.gettext("Filters applied") }</p>
            <div class="d-flex">
                <div class="d-flex flex-column filter" each="{ filter in state.reportData.formattedFilters }">
                    <span>{filter.title}: </span>
                    <span>{filter.values.join(", ")}</span>
                </div>
            </div>
        </div>

        <div if="{state.reportData.totalLength}" class="d-flex flex-column total-length" hidden="{ !hasTotalLength() }">
            <p>{ window.gettext("Total Length") }</p>
            <h1>{ (state.reportData.totalLength / 1000).toFixed(2) } km</h1>
        </div>

        <stacked_bar hidden="{ !state.road_status || !hasStackedBar(stackedBarIds.roadStatus) }" 
            id="{ stackedBarIds.roadStatus }" title="{ window.gettext('Road Status') }"
            entries="{ state.road_status }" total_title="{ window.gettext('Total road chainage') }">
        </stacked_bar>
        <stacked_bar hidden="{ !state.technical_class || !hasStackedBar(stackedBarIds.technicalClass) }" 
            id="{ stackedBarIds.technicalClass }" title="{ window.gettext('Technical Class') }"
            entries="{ state.technical_class }" total_title="{ window.gettext('Total road chainage') }">
        </stacked_bar>
        <stacked_bar hidden="{ !state.surface_condition || !hasStackedBar(stackedBarIds.surfaceCondition) }" 
            id="{ stackedBarIds.surfaceCondition }" title="{ window.gettext('Surface Condition (SDI)') }"
            entries="{ state.surface_condition }" total_title="{ window.gettext('Total road chainage') }">
        </stacked_bar>

        <data_table hidden="{ !state.reportData.municipality || !hasDataTable(dataTableIds.municipality) }"
            table_id="{dataTableIds.municipality}" tableName="Municipality"
            columns="{columns.municipality()}" columnSortOrder="{baseColumnSortOrder}"
            paging="false" canExport>
        </data_table>
        <data_table hidden="{ !state.reportData.roadClass || !hasDataTable(dataTableIds.roadClass) }"
            table_id="{dataTableIds.roadClass}" tableName="Road Class"
            columns="{columns.roadClass()}" columnSortOrder="{baseColumnSortOrder}"
            paging="false" canExport>
        </data_table>
        <data_table hidden="{ !state.reportData.surfaceType || !hasDataTable(dataTableIds.surfaceType) }"
            table_id="{dataTableIds.surfaceType}" tableName="Surface Type"
            columns="{columns.surfaceType()}" columnSortOrder="{baseColumnSortOrder}"
            paging="false" canExport>
        </data_table>
        <data_table hidden="{ !state.reportData.roadStatus || !hasDataTable(dataTableIds.roadStatus) }"
            table_id="{dataTableIds.roadStatus}" tableName="Road Status"
            columns="{columns.roadStatus()}" columnSortOrder="{baseColumnSortOrder}"
            paging="false" canExport>
        </data_table>
        <data_table hidden="{ !state.reportData.technicalClass || !hasDataTable(dataTableIds.technicalClass) }"
            table_id="{dataTableIds.technicalClass}" tableName="Technical Class"
            columns="{columns.technicalClass()}" columnSortOrder="{baseColumnSortOrder}"
            paging="false" canExport>
        </data_table>
        <data_table hidden="{ !state.reportData.surfaceCondition || !hasDataTable(dataTableIds.surfaceCondition) }"
            table_id="{dataTableIds.surfaceCondition}" tableName="Surface Condition"
            columns="{columns.surfaceCondition()}" columnSortOrder="{baseColumnSortOrder}"
            paging="false" canExport>
        </data_table>
    </div>

    <div if="{ state.noReport }" class="align-items-center blank content-wrapper d-flex flex-column justify-content-center">
        <span class="no-report image"></span>
        <h6>{ reportContent().noReportTitle }</h6>
        <p>{ reportContent().noReportDescription }</p>
    </div>

    <div if="{ state.noReportData }" class="align-items-center blank content-wrapper d-flex flex-column justify-content-center">
        <span class="no-report-data image"></span>
        <h6>{ reportContent().noReportData }</h6>
    </div>

    <div class="print-footer">
        <div class="d-flex align-items-center" if="{ state.reportData.dateCreated }">{ window.gettext("Exported from Estrada on") } { state.reportData.dateCreated() }</div>
        <span class="app-logo image"></span>
    </div>

    <script>
        import Stacked_Bar from "./stacked_bar.riot.html";

        // For each 'parent' primaryattribute of secondaryattribute values
        // add their reference data here
        import {
            ADMINISTRATIVE_AREA_CHOICES, // municipality
            ROAD_TYPE_CHOICES, // road_class / road_type
            SURFACE_TYPE_CHOICES // surface_type
        } from "../assets/models/road";

        import { getRoadReport, reportBarIds, reportColumns, reportContent, reportTableIds } from "../reportManager";
        import { updateReportAttributeSummary } from "../roadAttributes";
        import { cloneData, toChainageFormat } from "../assets/protoBufUtilities";

        import $ from "jquery";
        import "select2/dist/js/select2.full.min.js";
        import dayjs from "dayjs";

        const baseColumnSortOrder = [[0, 'asc']];

        // Ids of the report elements
        const allReportElements = {
            stackedBars: [reportBarIds.roadStatus, reportBarIds.technicalClass, reportBarIds.surfaceCondition],
            tables: [
                reportTableIds.municipality,
                reportTableIds.roadClass,
                reportTableIds.surfaceType,
                reportTableIds.roadStatus,
                reportTableIds.technicalClass,
                reportTableIds.surfaceCondition,
            ],
        };

        export default {
            state: {
                noReport: true,
                noReportData: false,
                filterDefinitions: [
                    { selectId: "municipality_area_select2", placeHolder: "Municipality", dataIn: "reportMunicipality", filterName: "municipality" },
                    { selectId: "road_class_select2", placeHolder: "Road class", dataIn: "reportRoadClass", filterName: "road_type" },
                    { selectId: "surface_type_select2", placeHolder: "Surface type", dataIn: "reportSurfaceType", filterName: "surface_type" },
                    { selectId: "surface_condition_select2", placeHolder: "Surface condition", dataIn: "reportSurfaceCondition", filterName: "surface_condition" },
                    { selectId: "road_code_select2", placeHolder: "Road code", dataIn: "reportRoadCode", isSingle: true, filterName: "road_code" },
                ],
                reportMunicipality: [],
                reportRoadClass: [],
                reportSurfaceType: [],
                reportSurfaceCondition: [],
                reportRoadCode: null,
                reportStartChainage: null,
                reportEndChainage: null,
                reportDate: true,
                reportData: {},
                road_status: [{ key: 0, title: "unknown", distance: 0, percent: 100, label: window.gettext("Loading") }],
                technical_class: [{ key: 0, title: "unknown", distance: 0, percent: 100, label: window.gettext("Loading") }],
                surface_condition: [{ key: 0, title: "unknown", distance: 0, percent: 100, label: window.gettext("Loading") }],
            },
            components: {
                Stacked_Bar
            },
            stackedBarIds: reportBarIds,
            dataTableIds: reportTableIds,
            columns: {
                municipality() {
                    const titleColumn = cloneData(reportColumns.title);
                    titleColumn.title = window.gettext("Municipality");

                    return [titleColumn, reportColumns.distance, reportColumns.percent];
                },
                roadClass() {
                    const titleColumn = cloneData(reportColumns.title);
                    titleColumn.title = window.gettext("Road Class");

                    return [titleColumn, reportColumns.distance, reportColumns.percent];
                },
                surfaceType() {
                    const titleColumn = cloneData(reportColumns.title);
                    titleColumn.title = window.gettext("Surface Type");

                    return [titleColumn, reportColumns.distance, reportColumns.percent];
                },
                roadStatus() {
                    const titleColumn = cloneData(reportColumns.title);
                    titleColumn.title = window.gettext("Road Status");

                    return [titleColumn, reportColumns.distance, reportColumns.percent];
                },
                technicalClass() {
                    const titleColumn = cloneData(reportColumns.title);
                    titleColumn.title = window.gettext("Technical Class");

                    return [titleColumn, reportColumns.distance, reportColumns.percent];
                },
                surfaceCondition() {
                    return [reportColumns.chainageStart, reportColumns.chainageEnd, reportColumns.surfaceCondition, reportColumns.surveyDate];
                },
            },
            reportContent() {
                // For the definitions of the reports themselves see reportContent in reportManager.js
                const reportId = this.props.id;
                return reportContent[reportId];
            },
            reportElements() {
                return this.reportContent().reportElements || allReportElements;
            },
            hasFilters() {
                return this.reportElements().filters;
            },
            hasRoadCodeAndChainage() {
                return this.reportElements().roadCodeAndChainage;
            },
            hasTotalLength() {
                return this.reportElements().totalLength;
            },
            hasStackedBar(stackedBarId) {
                return (this.reportElements().stackedBars || []).indexOf(stackedBarId) > -1;
            },
            hasDataTable(dataTableId) {
                return (this.reportElements().dataTables || []).indexOf(dataTableId) > -1;
            },
            onMounted(props, state) {
                state.filterDefinitions.forEach((filterDefinition) => {
                    this.prepareSelects(filterDefinition);
                });

                this.prepareStackedBar(this.stackedBarIds.surfaceCondition, this.state.surfaceConditions, "surface_condition");
            },
            prepareSelects(filterDefinition) {
                const selectOptions = {
                    width: "225px",
                    containerCssClass: "report-select2",
                    dropdownCssClass: "report-dropdown-select2",
                };

                let toggleFunction = this.toggleMultipleSelect2;
                if (filterDefinition.isSingle) {
                    selectOptions.multiple = false;
                    toggleFunction = this.toggleSingleSelect2;
                } else {
                    selectOptions.placeholder = window.gettext(filterDefinition.placeHolder)
                }

                $(`#${filterDefinition.selectId}`).select2(selectOptions);
                $(`#${filterDefinition.selectId}`).on('select2:select', null, filterDefinition.dataIn, toggleFunction);
                $(`#${filterDefinition.selectId}`).on('select2:unselect', null, filterDefinition.dataIn, toggleFunction);
            },
            backToReports() {
                window.location.hash = "reports/";
            },
            selectDate(e) {
                this.update({
                    reportDate: e.currentTarget.value,
                });
            },
            max_date: () => new Date().toISOString().substring(0, 10),
            current_date: () => dayjs(new Date()).format('YYYY-MM-DD'),
            selectStartChainage(e) {
                this.update({
                    reportStartChainage: e.currentTarget.value,
                });
            },
            selectEndChainage(e) {
                this.update({
                    reportEndChainage: e.currentTarget.value,
                });
            },
            toggleMultipleSelect2(e) {
                const selectElement = e.currentTarget;
                const inputElement = selectElement.nextSibling.children.item(0).firstElementChild;
                const selectedOptions = selectElement.selectedOptions;
                let values = [];

                for (let option of selectedOptions) {
                    values.push(option.text)
                };
                this.state[e.data] = values;

                if (selectElement.value !== "") {
                    inputElement.classList.add("active");
                } else {
                    inputElement.classList.remove("active");
                }
            },
            toggleSingleSelect2(e) {
                this.state[e.data] = e.currentTarget.value;
            },
            prepareTableData(tableName, tableData, filterName) {
                const haveTableData = tableData.length > 0;
                const fixedFilter = this.reportContent().fixedFilter;
                const isFixedFilter = fixedFilter.primaryattribute
                    ? fixedFilter.primaryattribute.indexOf(filterName) !== -1
                    : false;

                if (haveTableData || isFixedFilter) {
                    this.state.reportData.totalLength = this.state.reportData.totalLength || tableData.reduce((acc, cur) => acc += cur.distance || 0, 0);
                    tableData.forEach((entry) => {
                        if (this.state.reportData.totalLength > 0) {
                            entry.percent = Math.round((entry.distance / this.state.reportData.totalLength) * 10000) / 100;
                        } else {
                            // 100% of 0km - but this won't appear in the label
                            entry.percent = 100;
                        }
                        entry.getId = () => { return entry.key; };
                        entry.title = window.gettext(entry.title || entry.key);
                    });
                    const eventName = `${tableName}.dataAdded`;
                    const eventDetail = { detail: { pendingRows: tableData, clearRows: true } };
                    document.dispatchEvent(new CustomEvent(eventName, eventDetail));

                    return tableData || [];
                }

                return null;
            },
            prepareStackedBar(barName, barData, filterName) {
                if (barData && barData.length) {
                    updateReportAttributeSummary(this.state, filterName, barData);

                    this.state.reportData.totalLength = this.state.reportData.totalLength || barData.reduce((acc, cur) => acc += cur.distance || 0, 0);

                    const eventName = `${barName}.dataUpdated`;
                    const eventDetail = { detail: { entries: this.state[filterName], barName } };
                    document.dispatchEvent(new CustomEvent(eventName, eventDetail));
                } else {
                    delete this.state[filterName];
                }
            },
            toChainageFormat(value) {
                return toChainageFormat(value);
            },
            assembleFilters() {
                let filters = [];
                const filterSet = cloneData(this.reportContent().fixedFilter);

                // Handle the select filters
                this.state.filterDefinitions.forEach((filterDefinition) => {
                    const requestFilterName = filterDefinition.filterName || "";
                    if (!requestFilterName || filterSet[requestFilterName]) {
                        // If the fixedFilters already defines this request filter
                        // then we will not accept this user defined one
                        return;
                    }

                    const selectData = $(`#${filterDefinition.selectId}`).select2("data");
                    if (!selectData || selectData.length === 0) {
                        return;
                    }
                    const selection = selectData.map((data) => { return data.id; });

                    filterSet[requestFilterName] = selection;
                });
                // Check for the other filters
                if (this.state.reportDate) {
                    filterSet["reportdate"] = this.state.reportDate;
                }
                if (this.state.reportStartChainage) {
                    filterSet["reportstartchainage"] = this.state.reportStartChainage;
                }
                if (this.state.reportEndChainage) {
                    filterSet["reportendchainage"] = this.state.reportEndChainage;
                }

                // Secondary Attributes are handled in a special way
                // They result in multiple requests to the reports API
                // In effect each 'parent' primaryattribute (the keys in secondaryattribute)
                // is expanded out as a series of individual report requests
                let parentPrimaries = [];
                if (filterSet.secondaryattribute) {
                    // Verify the secondaryAttributes are correctly refencing their 'parents'
                    parentPrimaries = Object.keys(filterSet.secondaryattribute)
                        .filter((secondaryattribute) => {
                            return filterSet.primaryattribute.includes(secondaryattribute);
                        });
                }

                if (parentPrimaries.length === 0) {
                    // There were no secondary attributes or they didn't reference primaries properly
                    filters = [filterSet];
                    delete filterSet.secondaryattribute;
                } else {
                    // Build up the combinations of secondary attribute report filterSets
                    // by expanding out the relevant primary attributes
                    const expandedPrimaries = {};
                    parentPrimaries.forEach((parentPrimary) => {
                        // Check whether we have a relevant additional filter on a primary attribute
                        if (filterSet[parentPrimary]) {
                            expandedPrimaries[parentPrimary] = filterSet[parentPrimary];
                        } else {
                            let selectSource = "";
                            // For each 'parent' primaryattribute of secondaryattribute values
                            // add their reference data here
                            switch (parentPrimary) {
                                case "municipality": selectSource = ADMINISTRATIVE_AREA_CHOICES; break;
                                case "surface_type": selectSource = SURFACE_TYPE_CHOICES; break;
                                case "road_class":
                                case "road_type":
                                    selectSource = ROAD_TYPE_CHOICES;
                                    break;
                            }
                            if (selectSource) {
                                expandedPrimaries[parentPrimary] = Object.keys(selectSource);
                            }
                        }
                    });
                    const expandedPrimaryKeys = Object.keys(expandedPrimaries);
                    if (expandedPrimaryKeys.length === 0) {
                        // Somehow none of our expanded primaries matched up
                        // Have you (the programmer) made relevant code changes to support this secondaryattribute?
                        filters = [filterSet];
                        delete filterSet.secondaryattribute;
                    } else {
                        // The revised primary attributes will not included any that are 'expanded'
                        const revisedPrimary = filterSet.primaryattribute.filter((primaryattribute) => {
                            return !expandedPrimaryKeys.includes(primaryattribute);
                        });
                        // Build up a new collection of filterSets for every permutation we need
                        expandedPrimaryKeys.forEach((expandedPrimary) => {
                            // The new primary attributes will include the revised list
                            // plus the secondary attributes that relate to the expanded primary
                            const newPrimaryAttributes = [].concat(revisedPrimary, filterSet.secondaryattribute[expandedPrimary]);
                            expandedPrimaries[expandedPrimary].forEach((ep) => {
                                const newFilterSet = cloneData(filterSet);
                                newFilterSet.primaryattribute = newPrimaryAttributes;
                                newFilterSet[expandedPrimary] = [ep];
                                delete newFilterSet.secondaryattribute;
                                filters.push(newFilterSet);
                            });
                        });
                    }
                }

                return filters;
            },
            assembleSurveyReportData(surveyReportData) {
                this.state.noReport = false;
                const haveLengths = !!surveyReportData.lengths;

                this.state.reportData = {
                    totalLength: 0,
                    roadCodes: (surveyReportData.roadCodes || []).sort(),
                    reportChainage: (surveyReportData.reportChainage && surveyReportData.reportChainage.length === 2
                        && (surveyReportData.reportChainage[0] + surveyReportData.reportChainage[1]))
                        ? surveyReportData.reportChainage
                        : undefined,
                    dateCreated: () => dayjs(new Date()).format('DD MMMM YYYY [at] HH:mm'),
                    formattedFilters: surveyReportData.formattedFilters
                };

                if (haveLengths) {
                    this.state.reportData.municipality = this.prepareTableData(this.dataTableIds.municipality, surveyReportData.municipalities, "municipality");
                    this.state.reportData.roadClass = this.prepareTableData(this.dataTableIds.roadClass, surveyReportData.roadClasses, "road_type");
                    this.state.reportData.surfaceType = this.prepareTableData(this.dataTableIds.surfaceType, surveyReportData.surfaceTypes, "surface_type");

                    this.state.reportData.roadStatus = this.prepareTableData(this.dataTableIds.roadStatus, surveyReportData.roadStatuses, "road_status");
                    this.state.reportData.technicalClass = this.prepareTableData(this.dataTableIds.technicalClass, surveyReportData.technicalClasses, "technical_class");
                    const surfaceConditions = surveyReportData.attributes("surface_condition", null, false, true);
                    const surfaceConditionAttributes = surfaceConditions ? surfaceConditions.attributeEntries || [] : [];
                    this.state.reportData.surfaceCondition = this.prepareTableData(this.dataTableIds.surfaceCondition, surfaceConditionAttributes, "surface_condition");

                    this.prepareStackedBar(this.stackedBarIds.roadStatus, surveyReportData.roadStatuses, "road_type");
                    this.prepareStackedBar(this.stackedBarIds.technicalClass, surveyReportData.technicalClasses, "technical_class");
                    this.prepareStackedBar(this.stackedBarIds.surfaceCondition, surveyReportData.surfaceConditions, "surface_condition");

                    const reportingTables = this.reportElements().dataTables;
                    this.state.noReportData = true;
                    if (reportingTables.includes(this.dataTableIds.municipality) && surveyReportData.municipalities.length ||
                        reportingTables.includes(this.dataTableIds.roadClass) && surveyReportData.roadClasses.length ||
                        reportingTables.includes(this.dataTableIds.surfaceType) && surveyReportData.surfaceTypes.length ||
                        reportingTables.includes(this.dataTableIds.roadStatus) && surveyReportData.roadStatuses.length ||
                        reportingTables.includes(this.dataTableIds.technicalClass) && surveyReportData.technicalClasses.length ||
                        reportingTables.includes(this.dataTableIds.surfaceCondition) && surveyReportData.surfaceConditions.length) {
                        this.state.noReportData = false;
                    }
                } else {
                    this.state.noReportData = true;
                }
            },
            mergeReports(assembledReportData, survey) {
                Object.keys(survey.filter).forEach((filterKey) => {
                    assembledReportData[filterKey] = assembledReportData[filterKey] || [];
                    survey.filter[filterKey].forEach((filterValue) => {
                        if (!assembledReportData[filterKey].includes(filterValue)) {
                            assembledReportData[filterKey].push(filterValue);
                        }
                    });
                });
            },
            createReport(e) {
                $('#loading').modal('show');

                const reportId = e.currentTarget.dataset.id;
                const filters = this.assembleFilters();

                if (filters.length === 0 || filters.filter((f) => {return Object.keys(f).length;}).length === 0) {
                    return;
                }

                const getRoadReports = filters.map((f) => { return getRoadReport(f); });

                Promise.all(getRoadReports)
                    .then((surveyReportData) => {
                        switch (surveyReportData.length) {
                            case 0:
                                this.props.showFeedback(true);
                                this.state.noReport = true;
                                break;
                            case 1:
                                this.assembleSurveyReportData(surveyReportData[0]);
                                this.props.showFeedback();                                
                                break;
                            default:
                                // A report with secondaryattributes defined
                                // it will need 'assembling'
                                const assembledReportData = {
                                    filter: {},
                                    lengths: [],
                                    attributes: []
                                };
                                surveyReportData.forEach((survey) => {
                                    console.log(JSON.stringify(survey));
                                });
                                filters.primaryattribute.forEach((primaryattribute) => {
                                    const filteredSurveys = surveyReportData.filter((survey) => {
                                        return survey.filter[primaryattribute];
                                    })
                                    if (filteredSurveys.length === 1 && filteredSurveys[0].filter.primary_attribute.includes(primaryattribute)) {
                                        // We didn't have any secondaryattributes for this primaryattribute
                                        // so just merge it as-is
                                        assembledReportData = this.mergeReports(assembledReportData, filteredSurveys[0]);
                                    } else {
                                        
                                    }
                                });
                                break;
                        }
                    }).catch(err => {
                        this.props.showFeedback(true);
                        this.state.noReport = true;
                    }).finally((r) => {
                        $('#loading').modal('hide');
                        this.update();
                    });
            },
        }
    </script>
</report>
