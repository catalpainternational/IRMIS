<upload_photo>
    <div show="{state.photo.url == state.basePhoto.url}" class="photo-upload-area">
        <form class="dropzone">
            <div class="cloud-box">
                <div class="upload-cloud"></div>
                <div class="upload-instructions">{ window.gettext("Click to upload") }</div>
                <div>{ window.gettext("Maximum file size 500KB") }</div>
                <div>{ window.gettext("Accepted file formats: JPEG, GIF, PNG") }</div>
            </div>
        </form>
    </div>
    <div show="{state.photo.url != state.basePhoto.url}" class="photo-management-area">
        <img src="{state.photo.url}" style="max-width: 400px;">
        <input
            class="{ state.errors.description ? 'danger' : null } { state.photo.description ? '' : 'inactive' } form-control upload-text"
            type="text" maxlength="500" placeholder="Enter a description of the photo"
            value="{ state.photo.description }" onblur="{updateDescription}">
        <button class="btn btn-md btn-danger" onclick="{deletePhoto}">Delete Photo</button>
    </div>

    <script>
        import Dropzone from "dropzone";
        import {ConfigAPI} from "../assets/configAPI";
        import {putPhotoData, deletePhotoData} from "../assets/photoAPI";
        import {EstradaPhoto} from "../assets/models/photo";

        export default {
            state: {
                errors: {},
            },
            onBeforeMount(props, state) {
                state.basePhoto = new EstradaPhoto();
                state.photo = props.photo || new EstradaPhoto();
            },
            onMounted(props, state) {
                Dropzone.autoDiscover = false;
                const myDropzone = new Dropzone(this.$('form.dropzone'), {
                    url: `${ConfigAPI.requestAssetUrl}/photo_create`,
                    method: "post",
                    headers: {'X-CSRFToken': document.cookie.replace(/(?:(?:^|.*;\s*)csrftoken\s*\=\s*([^;]*).*$)|^.*$/, "$1")},
                    params: {fk_link: props.fkLink},
                    maxFiles: 1,
                    maxFilesize: 0.5, // MB
                    acceptedFiles: '.jpeg,.jpg,.gif,.png',
                    dictDefaultMessage: '',
                    dictInvalidFileType: 'Not a valid image, please submit a JPEG, GIF, or PNG',
                    accept: (file, done) => {
                        myDropzone.options.params["description"] = state.photo.description;
                        done();
                    }
                });

                this.photoCreationListener = (data) => {
                    const photo = data.detail.photo;
                    this.state.photo.setId(photo.id);
                    this.state.photo.setUrl(photo.url);
                    this.state.photo.setFkLink(photo.fk_link);
                    this.state.photo.setDescription(photo.description);
                    if (this.props.surveyPhoto) {
                        // if a survey Photo, add it to the NeedsLinkingQueue
                        document.dispatchEvent(new CustomEvent(`${props.photoId}.photoNeedsLinking`, {detail: {photo: this.state.photo}}));
                    }
                    this.update();
                };

                document.addEventListener(`${props.photoId}.photoCreated`, this.photoCreationListener);

                myDropzone.on("success", function(file, res) {
                    myDropzone.removeAllFiles();
                    document.dispatchEvent(new CustomEvent(`${props.photoId}.photoCreated`, {detail: {photo: res}}));
                });
                this.update();
            },
            updatePhoto() {
                putPhotoData(this.state.photo)
                    .then((data) => {
                        if (this.props.surveyPhoto) {
                            // if a survey Photo, update it's data in the NeedsLinkingQueue
                            document.dispatchEvent(new CustomEvent(`${this.props.photoId}.photoNeedsLinking`, {detail: {photo: this.state.photo}}));
                        } else {
                            this.props.showFeedback();
                        }
                    }).catch((err) => {
                        this.props.showFeedback(true);
                    }).finally((r) => {
                        this.update();
                    });
            },
            deletePhoto(e) {
                e.preventDefault();
                deletePhotoData(this.state.photo)
                    .then((data) => {
                        // before resetting state.photo, check if a survey Photo and remove from the NeedsLinkingQueue, if present.
                        if (this.props.surveyPhoto) {
                            document.dispatchEvent(new CustomEvent(`${this.props.photoId}.photoNeedsRemoval`, {detail: {photo: this.state.photo}}));
                        } else {
                            this.props.showFeedback();
                        }
                        this.state.photo = new EstradaPhoto();
                    }).catch((err) => {
                        this.props.showFeedback(true);
                    }).finally((r) => {
                        this.update();
                    });
            },
            updateDescription(e) {
                const description = e.currentTarget.value.trim();
                if (this.state.photo.description != description) {
                    this.state.photo.setDescription(description);
                    // check that a photo is uploaded/present first before firing an update
                    if (this.state.photo.url != this.state.basePhoto.url) {
                        this.updatePhoto();
                    }
                }
            },
        }
    </script>
</upload_photo>
