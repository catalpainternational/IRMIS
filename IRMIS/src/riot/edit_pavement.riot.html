<edit_pavement>
    <div class="content-wrapper">
        <stacked_bar id="{ surface_stacked_bar_id }" title="{ window.gettext('Surface Type') }"
            entries="{ state.surfaceTypes }" total_title="{ window.gettext('Total road chainage') }"></stacked_bar>
    </div>
    <div class="content-wrapper">
        <stacked_bar id="{ pavement_stacked_bar_id }" title="{ window.gettext('Pavement Class') }"
            entries="{ state.pavementClasses }" total_title="{ window.gettext('Total road chainage') }"></stacked_bar>
    </div>

    <div class="content-wrapper">
        <div class="d-flex justify-content-between">
            <h5>{ window.gettext("Surface Type Data (SDI)") }</h5>
            <button class="btn btn-primary" onclick="{ addEditSurface }" disabled="{ props.editing }">
                { window.gettext("Add") }
            </button>
        </div>
        <div class="d-flex">
            <a class="{ !state.viewAllSurface ? 'active' : '' } table-toggle" onclick="{ viewCurrentSurface }">
                { window.gettext("Current type") }</a>
            <a class="{ state.viewAllSurface ? 'active' : '' } table-toggle" onclick="{ viewAllSurface }">
                { window.gettext("View all data entries") }</a>
        </div>
        <data_table if="{ state.viewAllSurface }" table_id="{surface_all_data_table_id}"
            columns="{surface_all_data_table_columns}" columnSortOrder="{surface_all_data_table_columns_order}"
            getHelpText="{props.parent.getHelpText}" pendingRows="{state.pendingRows['surface_type']}" canDelete=true>
        </data_table>
        <data_table if="{ !state.viewAllSurface }" table_id="{surface_current_data_table_id}"
            columns="{surface_current_data_table_columns}" columnSortOrder="{surface_current_data_table_columns_order}"
            getHelpText="{props.parent.getHelpText}" pendingRows="{state.pendingRows['surface_type']}"></data_table>
    </div>

    <div class="content-wrapper">
        <div class="d-flex justify-content-between">
            <h5>{ window.gettext("Pavement Class Data") }</h5>
            <button class="btn btn-primary" onclick="{ addEditPavement }" disabled="{ props.editing }">
                { window.gettext("Add") }</button>
        </div>
        <div class="d-flex">
            <a class="{ !state.viewAllPavement ? 'active' : '' } table-toggle" onclick="{ viewCurrentPavement }">
                { window.gettext("Current type") }</a>
            <a class="{ state.viewAllPavement ? 'active' : '' } table-toggle" onclick="{ viewAllPavement }">
                { window.gettext("View all data entries") }</a>
        </div>
        <data_table if="{ state.viewAllPavement }" table_id="{pavement_all_data_table_id}"
            columns="{pavement_all_data_table_columns}" columnSortOrder="{pavement_all_data_table_columns_order}"
            getHelpText="{props.parent.getHelpText}" pendingRows="{state.pendingRows['pavement_class']}" canDelete=true>
        </data_table>
        <data_table if="{ !state.viewAllPavement }" table_id="{pavement_current_data_table_id}"
            columns="{pavement_current_data_table_columns}"
            columnSortOrder="{pavement_current_data_table_columns_order}" getHelpText="{props.parent.getHelpText}"
            pendingRows="{state.pendingRows['pavement_class']}"></data_table>
    </div>

    <edit_modal modal_id="{ surface_modal_id }" disableSave="{ !state.canSave }">
        <span slot="modal_title">{window.gettext("Add Surface Type Information")}</span>

        <form slot="modal_body">
            <section>
                <div class="form-group">
                    <label>{ window.gettext("Survey Date") }</label>
                    <span class="required">*</span>
                    <small class="form-text text-muted">{props.parent.getHelpText("survey_date")}</small>
                    <!-- It would be preferable to use the 'datetime-local' input type, however Firefox currently does not support it -->
                    <input
                        class="{ state.errors.surveyDate ? 'danger' : null } { state.survey.surveyDate ? '' : 'inactive' } form-control"
                        type="date" name="surveyDate" placeholder="Date" value="{ state.survey.surveyDate }"
                        oninput="{ checkSurveyDate }" required pattern="\d{4}-\d{2}-\d{2}" max="{ max_date() }">
                    <div if="{ state.errors.surveyDate }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.surveyDate }.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section>
                <h6>{ window.gettext("Chainage") }</h6>
                <div class="form-group">
                    <label>{ window.gettext("Chainage start") }</label>
                    <span class="required">*</span>
                    <input
                        class="{ state.errors.startChainage ? 'danger' : null } { state.survey.startChainage ? '' : 'inactive' } form-control"
                        type="number" name="startChainage" placeholder="0+000" value="{ state.survey.startChainage }"
                        oninput="{ checkChainage }" required>
                    <small class="form-text text-muted">{ props.parent.getHelpText("start_chainage") }</small>
                    <div if="{ state.errors.startChainage }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.startChainage }.</li>
                        </ul>
                    </div>
                </div>
                <div class="form-group">
                    <label>{ window.gettext("Chainage end") }</label>
                    <span class="required">*</span>
                    <input
                        class="{ state.errors.endChainage ? 'danger' : null } { state.survey.endChainage ? '' : 'inactive' } form-control"
                        type="number" name="endChainage" placeholder="62+410" value="{ state.survey.endChainage }"
                        oninput="{ checkChainage }" required>
                    <small class="form-text text-muted">{ props.parent.getHelpText("end_chainage") }</small>
                    <div if="{ state.errors.endChainage }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.endChainage }.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section>
                <h6>{ window.gettext("Surface Type") }</h6>
                <div class="form-group">
                    <label>{ surfaces.display }</label>
                    <span class="required">*</span>
                    <div if="{ state.errors.surfaceType }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.surfaceType }.</li>
                        </ul>
                    </div>
                    <select class="{ state.surfaceType ? '' : 'inactive' } form-control" onchange="{ checkSurfaceType }"
                        name="surfaceType">
                        <option value="">{ window.gettext("Select a Surface Type") }</option>
                        <option each="{ surface in surfaces.options }" value="{ surface.code }"
                            selected="{ surface.code == state.surfaceType }">{ surface.name }</option>
                    </select>
                    <small class="form-text text-muted">{ props.parent.getHelpText("surface_type") }</small>
                </div>
            </section>

            <div class="d-flex justify-content-end">
                <span>[</span><span class="required">*</span><span>]: Mandatory</span>
            </div>
        </form>
    </edit_modal>

    <edit_modal modal_id="{ pavement_modal_id }" disableSave="{ !state.canSave }">
        <span slot="modal_title">{window.gettext("Add Pavement Class Information")}</span>

        <form slot="modal_body">
            <section>
                <div class="form-group">
                    <label>{ window.gettext("Survey Date") }</label>
                    <span class="required">*</span>
                    <small class="form-text text-muted">{props.parent.getHelpText("survey_date")}</small>
                    <!-- It would be preferable to use the 'datetime-local' input type, however Firefox currently does not support it -->
                    <input
                        class="{ state.errors.surveyDate ? 'danger' : null } { state.survey.surveyDate ? '' : 'inactive' } form-control"
                        type="date" name="surveyDate" placeholder="Date" value="{ state.survey.surveyDate }"
                        oninput="{ checkSurveyDate }" required pattern="\d{4}-\d{2}-\d{2}" max="{ max_date() }">
                    <div if="{ state.errors.surveyDate }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.surveyDate }.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section>
                <h6>{ window.gettext("Chainage") }</h6>
                <div class="form-group">
                    <label>{ window.gettext("Chainage start") }</label>
                    <span class="required">*</span>
                    <input
                        class="{ state.errors.startChainage ? 'danger' : null } { state.survey.startChainage ? '' : 'inactive' } form-control"
                        type="number" name="startChainage" placeholder="0+000" value="{ state.survey.startChainage }"
                        oninput="{ checkChainage }" required>
                    <small class="form-text text-muted">{ props.parent.getHelpText("start_chainage") }</small>
                    <div if="{ state.errors.startChainage }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.startChainage }.</li>
                        </ul>
                    </div>
                </div>
                <div class="form-group">
                    <label>{ window.gettext("Chainage end") }</label>
                    <span class="required">*</span>
                    <input
                        class="{ state.errors.endChainage ? 'danger' : null } { state.survey.endChainage ? '' : 'inactive' } form-control"
                        type="number" name="endChainage" placeholder="62+410" value="{ state.survey.endChainage }"
                        oninput="{ checkChainage }" required>
                    <small class="form-text text-muted">{ props.parent.getHelpText("end_chainage") }</small>
                    <div if="{ state.errors.endChainage }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.endChainage }.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section>
                <h6>{ window.gettext("Pavement Class") }</h6>
                <div class="form-group">
                    <label>{ pavements.display }</label>
                    <span class="required">*</span>
                    <small class="form-text text-muted">{ props.parent.getHelpText("pavement_class") }</small>
                    <div if="{ state.errors.pavementClass }" class="invalid-tooltip">
                        <ul>
                            <li>{ state.errors.pavementClass }.</li>
                        </ul>
                    </div>
                    <ul class="pavement-classes" name="pavementClass">
                        <li each="{ pavement in pavements.options }" data-condition="{ pavement.code }"
                            onclick="{ checkPavementClass }">
                            <span
                                class="{pavement.code == state.survey.pavementClass ? 'active' : ''} radio image"></span>
                            { pavement.name }
                        </li>
                    </ul>
                </div>
            </section>

            <div class="d-flex justify-content-end">
                <span>[</span><span class="required">*</span><span>]: Mandatory</span>
            </div>
        </form>
    </edit_modal>

    <edit_stop_alert modalId="delete-alert" title="{ window.gettext('Delete') }"
        description="{ window.gettext('Are you sure you want to delete this data entry?') }"
        proceedLabel="{ window.gettext('Delete') }" proceedResult="delete"
        stopLabel="{ window.gettext('Don\'t delete') }" stopResult="keep">
    </edit_stop_alert>

    <script>
        import Edit_Stop_Alert from "./edit_stop_alert.riot.html";
        import Data_Table from "./data_table.riot.html";
        import Edit_Modal from "./edit_modal.riot.html";
        import Stacked_Bar from "./stacked_bar.riot.html";

        import {createSurvey, deleteSurvey, updateSurvey} from "../surveyManager";
        import {cloneData, toChainageFormat} from "../assets/protoBufUtilities";
        import {Survey, Report} from "../../protobuf/survey_pb";

        import $ from "jquery";

        function checkRequiredFields(fieldNames, data, errors) {
            return fieldNames.filter((fieldName) => {return !data[fieldName];});
        }

        function withinMaxDigits(text, limit, decimals) {
            return (new RegExp(`^\\d{0,${(limit - decimals)}}(\\.\\d{1,${decimals}})?$`).test(text));
        }

        export default {
            state: {
                chainageDecimals: 3,
                chainageDigits: 9,
                baseSurvey: new Survey({}),
                survey: {},
                canSave: false,
                errors: {},
                surveyTotalDistance: 0,
                pendingRows: {
                    "pavement_class": [],
                    "surface_type": [],
                },
                reportRows: {
                    "pavement_class": [],
                    "surface_type": [],
                },
                surfaceTypes: [{key: 0, title: "unknown", distance: 0, percent: 100, label: window.gettext("Loading")}],
                pavementClasses: [{key: 0, title: "unknown", distance: 0, percent: 100, label: window.gettext("Loading")}],
                viewAllSurface: false,
                viewAllPavement: false,
                editMode: false,
                // Current Attribute type Modal / Editing tracking
                currentModalId: false,
                currentRequiredFieldNames: [],
                currentEditing: false,
            },
            components: {
                Edit_Stop_Alert, Edit_Modal, Stacked_Bar
            },

            // Condition Survey
            onMounted(props, state) {
                state.loading = true;
                state.road = cloneData(props.road);

                this.props.parent.updateReportAttributeSummary(state, "surface_type", props.parent.emptyAttributes);
                this.props.parent.updateReportAttributeSummary(state, "pavement_class", props.parent.emptyAttributes);

                this.props.parent.refreshSurveysAndReports(state, this.surface_all_data_table_id, "surface_type", "surfaceTypes", this.surface_current_data_table_id, this.surface_stacked_bar_id);
                this.props.parent.refreshSurveysAndReports(state, this.pavement_all_data_table_id, "pavement_class", "pavementClasses", this.pavement_current_data_table_id, this.pavement_stacked_bar_id);

                this.deleteListener = (data) => {
                    const rowId = data.detail.rowId;
                    this.showStopAlertModal("delete-alert", rowId);
                };

                document.addEventListener(`${this.surface_all_data_table_id}.deleteRow`, this.deleteListener);
                document.addEventListener(`${this.pavement_all_data_table_id}.deleteRow`, this.deleteListener);
            },
            onUnmount(props, state) {
                document.removeEventListener(`${this.surface_all_data_table_id}.deleteRow`, this.deleteListener);
                document.removeEventListener(`${this.pavement_all_data_table_id}.deleteRow`, this.deleteListener);
            },
            viewAllPavement(e) {
                if (!this.state.viewAllPavement) {
                    this.state.viewAllPavement = true;
                    this.update();
                    this.props.parent.refreshSurveysAndReports(this.state, this.pavement_all_data_table_id, "pavement_class", "pavementClasses", this.pavement_current_data_table_id, this.pavement_stacked_bar_id);
                    // If we're not still loading, then we assume that we want to replace all rows
                    const eventName = `${this.pavement_all_data_table_id}.dataAdded`;
                    const eventDetail = {detail: {pendingRows: this.state.pendingRows["pavement_class"], appendRows: this.state.loading}}
                    document.dispatchEvent(new CustomEvent(eventName, eventDetail));
                }
            },
            viewAllSurface(e) {
                if (!this.state.viewAllSurface) {
                    this.state.viewAllSurface = true;
                    this.update();
                    this.props.parent.refreshSurveysAndReports(this.state, this.surface_all_data_table_id, "surface_type", "surfaceTypes", this.surface_current_data_table_id, this.surface_stacked_bar_id);
                    // If we're not still loading, then we assume that we want to replace all rows
                    const eventName = `${this.surface_all_data_table_id}.dataAdded`;
                    const eventDetail = {detail: {pendingRows: this.state.pendingRows["surface_type"], appendRows: this.state.loading}}
                    document.dispatchEvent(new CustomEvent(eventName, eventDetail));
                }
            },
            viewCurrentPavement(e) {
                if (this.state.viewAllPavement) {
                    this.state.viewAllPavement = false;
                    this.update();
                    this.props.parent.refreshSurveysAndReports(this.state, this.pavement_all_data_table_id, "pavement_class", "pavementClasses", this.pavement_current_data_table_id, this.pavement_stacked_bar_id);
                    // If we're not still loading, then we assume that we want to replace all rows
                    const eventName = `${this.pavement_current_data_table_id}.dataAdded`;
                    const eventDetail = {detail: {pendingRows: this.state.reportRows["pavement_class"], appendRows: this.state.loading}}
                    document.dispatchEvent(new CustomEvent(eventName, eventDetail));
                }
            },
            viewCurrentSurface(e) {
                if (this.state.viewAllSurface) {
                    this.state.viewAllSurface = false;
                    this.update();
                    this.props.parent.refreshSurveysAndReports(this.state, this.surface_all_data_table_id, "surface_type", "surfaceTypes", this.surface_current_data_table_id, this.surface_stacked_bar_id);
                    // If we're not still loading, then we assume that we want to replace all rows
                    const eventName = `${this.surface_current_data_table_id}.dataAdded`;
                    const eventDetail = {detail: {pendingRows: this.state.reportRows["surface_type"], appendRows: this.state.loading}}
                    document.dispatchEvent(new CustomEvent(eventName, eventDetail));
                }
            },
            addEditPavement(e) {
                this.state.survey = cloneData(this.state.baseSurvey);
                this.state.errors = {};
                this.state.currentEditing = "pavement_class";
                this.state.currentModalId = this.pavement_modal_id;
                this.state.currentRequiredFieldNames = this.pavementRequiredFieldNames;
                this.showEditModal();
            },
            addEditSurface(e) {
                this.state.survey = cloneData(this.state.baseSurvey);
                this.state.errors = {};
                this.state.currentEditing = "surface_type";
                this.state.currentModalId = this.surface_modal_id;
                this.state.currentRequiredFieldNames = this.surfaceRequiredFieldNames;
                this.showEditModal();
            },

            // Tables / Modal IDs
            surface_stacked_bar_id: "surface-type-stacked-bar",
            surface_current_data_table_id: "surface-type-report-table",
            surface_all_data_table_id: "surface-type-table",
            surface_modal_id: "surface-type-modal",
            pavement_stacked_bar_id: "pavement-class-stacked-bar",
            pavement_current_data_table_id: "pavement-class-report-table",
            pavement_all_data_table_id: "pavement-class-table",
            pavement_modal_id: "pavement-class-modal",

            // Surface Type Table
            surfaces: window.road_schema.surface_type,
            surface_current_data_table_columns_order: [[0, 'asc']],
            surface_current_data_table_columns: [
                {
                    title: window.gettext("Chainage start"),
                    data: "chainageStart",
                    defaultContent: "",
                    className: "text-right",
                    render: (data, type) => {
                        return (type === 'display') ? toChainageFormat(data) : data;
                    },
                },
                {
                    title: window.gettext("Chainage end"),
                    data: "chainageEnd",
                    defaultContent: "",
                    className: "text-right",
                    orderable: false,
                    render: (data, type) => {
                        return (type === 'display') ? toChainageFormat(data) : data;
                    },
                },
                {
                    title: window.gettext("Surface type"),
                    data: "surfaceType",
                    defaultContent: "",
                    className: "text-center",
                    orderable: false,
                },
                {
                    title: window.gettext("Survey date"),
                    data: "dateSurveyed",
                    defaultContent: "",
                    className: "text-center",
                    orderable: false,
                },
                {
                    title: window.gettext("Added by"),
                    data: "addedBy",
                    defaultContent: "",
                    orderable: false,
                },
            ],

            surface_all_data_table_columns_order: [[3, 'desc'], [0, 'asc']],
            surface_all_data_table_columns: [
                {
                    title: window.gettext("Chainage start"),
                    data: "chainageStart",
                    defaultContent: "",
                    className: "text-right",
                    render: (data, type) => {
                        return (type === 'display') ? toChainageFormat(data) : data;
                    },
                },
                {
                    title: window.gettext("Chainage end"),
                    data: "chainageEnd",
                    defaultContent: "",
                    className: "text-right",
                    orderable: false,
                    render: (data, type) => {
                        return (type === 'display') ? toChainageFormat(data) : data;
                    },
                },
                {
                    title: window.gettext("Surface type"),
                    data: "surfaceType",
                    defaultContent: "",
                    className: "text-center",
                    orderable: false,
                },
                {
                    title: window.gettext("Survey date"),
                    data: "dateSurveyed",
                    defaultContent: "",
                    className: "text-center",
                },
                {
                    title: window.gettext("Added by"),
                    data: "addedBy",
                    defaultContent: "",
                    orderable: false,
                },
                {
                    // To add a 'Delete' button include the attribute candelete=true
                    // on the Riot dataTable tag as well
                    title: window.gettext("Delete"),
                    name: "Option", // Do NOT translate this
                    defaultContent: "",
                    className: "text-center",
                    orderable: false,
                },
            ],
            // Pavement Class Table
            pavements: window.road_schema.pavement_class,
            pavement_current_data_table_columns_order: [[0, 'asc']],
            pavement_current_data_table_columns: [
                {
                    title: window.gettext("Chainage start"),
                    data: "chainageStart",
                    defaultContent: "",
                    className: "text-right",
                    render: (data, type) => {
                        return (type === 'display') ? toChainageFormat(data) : data;
                    },
                },
                {
                    title: window.gettext("Chainage end"),
                    data: "chainageEnd",
                    defaultContent: "",
                    className: "text-right",
                    orderable: false,
                    render: (data, type) => {
                        return (type === 'display') ? toChainageFormat(data) : data;
                    },
                },
                {
                    title: window.gettext("Pavement class"),
                    data: "pavementClass",
                    defaultContent: "",
                    className: "text-center",
                    orderable: false,
                },
                {
                    title: window.gettext("Survey date"),
                    data: "dateSurveyed",
                    defaultContent: "",
                    className: "text-center",
                    orderable: false,
                },
                {
                    title: window.gettext("Added by"),
                    data: "addedBy",
                    defaultContent: "",
                    orderable: false,
                },
            ],
            pavement_all_data_table_columns_order: [[3, 'desc'], [0, 'asc']],
            pavement_all_data_table_columns: [
                {
                    title: window.gettext("Chainage start"),
                    data: "chainageStart",
                    defaultContent: "",
                    className: "text-right",
                    render: (data, type) => {
                        return (type === 'display') ? toChainageFormat(data) : data;
                    },
                },
                {
                    title: window.gettext("Chainage end"),
                    data: "chainageEnd",
                    defaultContent: "",
                    className: "text-right",
                    orderable: false,
                    render: (data, type) => {
                        return (type === 'display') ? toChainageFormat(data) : data;
                    },
                },
                {
                    title: window.gettext("Pavement class"),
                    data: "pavementClass",
                    defaultContent: "",
                    className: "text-center",
                    orderable: false,
                },
                {
                    title: window.gettext("Survey date"),
                    data: "dateSurveyed",
                    defaultContent: "",
                    className: "text-center",
                },
                {
                    title: window.gettext("Added by"),
                    data: "addedBy",
                    defaultContent: "",
                    orderable: false,
                },
                {
                    // To add a 'Delete' button include the attribute candelete=true
                    // on the Riot dataTable tag as well
                    title: window.gettext("Delete"),
                    name: "Option", // Do NOT translate this
                    defaultContent: "",
                    className: "text-center",
                    orderable: false,
                },
            ],

            // Surveys Modal
            surfaceRequiredFieldNames: ["surveyDate", "startChainage", "endChainage", "surfaceType"],
            pavementRequiredFieldNames: ["surveyDate", "startChainage", "endChainage", "pavementClass"],

            showEditModal() {
                document.addEventListener(`${this.state.currentModalId}.result`, (data) => {
                    const modalResult = data.detail.result;

                    switch (modalResult) {
                        case "save":
                            if (this.hasChanges()) {
                                this.save();
                            }
                            break;
                        case "cancel":
                            this.discardChanges();
                            break;
                        default:
                            if (this.hasChanges()) {
                                this.showStopAlertModal("stop-alert");
                            }
                            break;
                    }
                }, {once: true});

                $(`#${this.state.currentModalId}`).modal("show");
            },
            showStopAlertModal(modalId, rowId) {
                const eventName = `edit.${modalId}.result`;

                document.addEventListener(eventName, (data) => {
                    const stopAlertResult = data.detail.result;
                    $(`#${modalId}`).modal("hide");

                    if (stopAlertResult === "discard") {
                        this.discardChanges();
                    } else if (stopAlertResult === "delete") {
                        this.state.editMode = true;
                        // void the survey attribute value and save
                        let allSurveys = [];
                        if (this.state.pendingRows['survey_type'] || this.state.pendingRows['pavement_class']) {
                            allSurveys = this.state.pendingRows['survey_type'].concat(this.state.pendingRows['pavement_class']);
                        } else {
                            allSurveys = this.state.pendingRows;
                        }
                        this.state.survey = allSurveys.find((s) => {return s.id == rowId;});
                        if (this.state.survey) {
                            this.state.survey.setValues(JSON.stringify({}));
                            this.saveSurvey();
                        }
                        this.state.editMode = false;
                    } else if (stopAlertResult === "continueEdit") {
                        this.showEditModal();
                    }
                }, {once: true});

                $(`#${modalId}`).modal("show");
            },
            discardChanges() {
                $(`#${this.state.currentModalId}`).modal("hide");
                this.update({
                    survey: cloneData(this.state.baseSurvey),
                    errors: {},
                    currentEditing: false,
                    currentModalId: false,
                    currentRequiredFieldNames: [],
                });
            },
            save(e) {
                const missingFieldNames = checkRequiredFields(this.state.currentRequiredFieldNames, this.state.survey);
                if (Object.keys(this.state.errors).length) {
                    // Cannot save if there are validation errors
                    this.canSave();
                    if (!this.state.canSave) {
                        missingFieldNames.forEach((fieldName) => {
                            if (!data[fieldName]) {
                                errors[fieldName] = window.gettext("This field is required");
                            }
                        });
                        this.showEditModal();
                    }
                } else {
                    if (this.hasChanges()) {
                        // Complete the survey
                        this.state.survey.setUser($("#user_welcome").data("userId") || 0);
                        this.state.survey.setSource("Estrada");
                        this.state.survey.setChainageStart(this.state.survey.startChainage);
                        this.state.survey.setChainageEnd(this.state.survey.endChainage);
                        if (this.state.currentEditing == "pavement_class") {
                            this.state.survey.setValues(JSON.stringify({
                                pavement_class: this.state.survey.pavementClass || null,
                            }));
                        } else {
                            this.state.survey.setValues(JSON.stringify({
                                surface_type: this.state.survey.surfaceType || null,
                            }));
                        }
                        // If we're here we will have a user entered surveyDate, even so Date.now() is still used as a fall back
                        const dateSurveyed = new proto.google.protobuf.Timestamp();
                        const surveyDate = new Date(this.state.survey.surveyDate || Date.now().toISOString());
                        dateSurveyed.fromDate(surveyDate);
                        this.state.survey.setDateSurveyed(dateSurveyed);
                        // set Survey road from state Road road_code
                        this.state.survey.setRoad(this.state.road.getRoadCode());
                        this.saveSurvey();
                    }

                    // Reset baseSurvey now that we're done.
                    this.baseSurvey = new Survey({});
                    $(`#${this.state.currentModalId}`).modal("hide");
                }
            },
            saveSurvey() {
                $(`#${this.state.currentModalId}`).modal("hide");
                $('#loading').modal('show');

                if (!this.state.editMode) {
                    createSurvey(this.state.survey)
                        .then((surveyData) => {
                            if (this.state.currentEditing == 'pavement_class') {
                                this.props.parent.refreshSurveysAndReports(this.state, this.pavement_all_data_table_id, "pavement_class", "pavementClasses", this.pavement_current_data_table_id, this.pavement_stacked_bar_id);
                            } else {
                                this.props.parent.refreshSurveysAndReports(this.state, this.surface_all_data_table_id, "surface_type", "surfaceTypes", this.surface_current_data_table_id, this.surface_stacked_bar_id);
                            }
                            this.update({
                                survey: new Survey({}), // clear input values
                            });
                            $('#loading').modal('hide');
                            this.props.showFeedback();
                        })
                        .catch((err) => {
                            this.props.showFeedback(true);
                        });
                } else {
                    updateSurvey(this.state.survey)
                        .then((surveyData) => {
                            this.props.parent.refreshSurveysAndReports(this.state, this.pavement_all_data_table_id, "pavement_class", "pavementClasses", this.pavement_current_data_table_id, this.pavement_stacked_bar_id);
                            this.props.parent.refreshSurveysAndReports(this.state, this.surface_all_data_table_id, "surface_type", "surfaceTypes", this.surface_current_data_table_id, this.surface_stacked_bar_id);
                            this.update({
                                survey: new Survey({}), // clear input values
                            });
                            $('#loading').modal('hide');
                            this.props.showFeedback();
                        })
                        .catch((err) => {
                            this.props.showFeedback(true);
                        });
                }
                // clear input values
                this.state.survey = new Survey({});
                this.state.errors = {};
                this.update();
            },
            canSave() {
                const missingFieldNames = checkRequiredFields(this.state.currentRequiredFieldNames, this.state.survey);
                if (missingFieldNames.length || Object.keys(this.state.errors).length) {
                    // Cannot save if there are validation errors
                    this.state.canSave = false;
                } else {
                    // Can save if something has changed
                    this.state.canSave = JSON.stringify(this.state.baseSurvey) !== JSON.stringify(this.state.survey);
                }
                this.update();
            },
            /** Compare the selected fields between baseSurvey and survey.
             * `source` and `user` are deliberately not compared
             */
            hasChanges() {
                const compareFieldNames = ["surveyDate", "startChainage", "endChainage", this.state.currentEditing];
                const surveyBase = compareFieldNames.map((fieldName) => {return this.state.baseSurvey[fieldName] || "";}).join("|||");
                const surveyResult = compareFieldNames.map((fieldName) => {return this.state.survey[fieldName] || "";}).join("|||");
                return (surveyBase !== surveyResult);
            },
            validate(fieldName, input, testResult, errorText) {
                if (!testResult) {
                    this.state.errors[fieldName] = errorText;
                } else {
                    delete this.state.errors[fieldName];
                    this.state.survey[fieldName] = input;
                }
                this.canSave();
            },
            checkSurveyDate(e) {
                const fieldName = e.currentTarget.name;
                const input = e.currentTarget.value;
                const testResult = input <= this.max_date();
                const errorText = window.gettext("Survey date cannot be in the future");

                this.validate(fieldName, input, testResult, errorText);
            },
            checkChainage(e) {
                const fieldName = e.currentTarget.name;
                const input = e.currentTarget.value;
                const chainageDigits = this.state.chainageDigits;
                const chainageDecimals = this.state.chainageDecimals;
                const testResult = withinMaxDigits(input, chainageDigits, chainageDecimals);
                const errorText = window.interpolate(
                    window.gettext("Chainage cannot contain more than %s digits, of which %s are decimals"),
                    [chainageDigits, chainageDecimals]);

                this.validate(fieldName, input, testResult, errorText);
            },
            checkSurfaceType(e) {
                this.state.survey.surfaceType = e.currentTarget.value;
                this.canSave();
            },
            checkPavementClass(e) {
                this.state.survey.pavementClass = e.currentTarget.dataset.condition;
                this.canSave();
            },
            max_date: () => new Date().toISOString().substring(0, 10),
        }
    </script>
</edit_pavement>
